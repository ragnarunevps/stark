<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberGlobe: Ethical Hacking System Navigator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 5px;
            display: none;
            z-index: 100;
            max-height: 400px;
            overflow-y: auto;
        }
        #info-panel h3 {
            margin: 0 0 10px 0;
            color: #00ff41;
        }
        #info-panel ul {
            margin: 0;
            padding-left: 20px;
        }
        #info-panel li {
            margin-bottom: 5px;
            list-style-type: square;
        }
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 18px;
            z-index: 200;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        button {
            background: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 3px;
            font-family: inherit;
        }
        button:hover {
            background: #00ff00;
            color: #000;
        }
    </style>
</head>
<body>
    <div id="loading">Initializing CyberGlobe... Scanning neural net for threats...</div>
    <div id="info-panel">
        <h3 id="node-title">Node Info</h3>
        <ul id="node-details"></ul>
    </div>
    <div id="legend">
        <strong>Layers:</strong><br>
        <span style="color:#ff0000">● Perimeter (Red)</span><br>
        <span style="color:#ffff00">● Infrastructure (Yellow)</span><br>
        <span style="color:#00ff00">● Core (Green)</span><br>
        <span style="color:#0000ff">● Attack Paths (Blue Lines)</span>
    </div>
    <div id="controls">
        <button onclick="resetView()">Reset View</button>
        <button onclick="togglePaths()">Toggle Paths</button>
        <button onclick="scanForVulns()">Scan Vulns</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let layers = {}; // Store layer groups
        let nodes = []; // All interactive nodes
        let connections = []; // Line segments for paths
        let showPaths = true;
        let scanning = false;

        // Node data: Each node has position (spherical coords), layer, type, vulns, nextSteps
        const nodeData = [
            // Perimeter Layer (outer, radius 10)
            { name: 'Firewall', layer: 'perimeter', type: 'defense', radius: 10, phi: 0, theta: 0, vulns: ['Misconfig', 'Rule Bypass'], nextSteps: ['Probe Ports', 'Social Eng'] },
            { name: 'IDS/IPS', layer: 'perimeter', type: 'defense', radius: 10, phi: Math.PI/4, theta: Math.PI/2, vulns: ['Signature Evasion', 'DoS'], nextSteps: ['Craft Payloads', 'Tunnel Traffic'] },
            { name: 'Load Balancer', layer: 'perimeter', type: 'infra', radius: 10, phi: Math.PI/2, theta: Math.PI, vulns: ['SSL Termination Flaw', 'Rate Limit Bypass'], nextSteps: ['SSLStrip', 'DDoS'] },
            
            // Infrastructure Layer (middle, radius 6)
            { name: 'Web Server', layer: 'infra', type: 'app', radius: 6, phi: 0, theta: Math.PI/3, vulns: ['XSS', 'CSRF'], nextSteps: ['Reflected XSS', 'Session Hijack'] },
            { name: 'API Gateway', layer: 'infra', type: 'app', radius: 6, phi: Math.PI/3, theta: 2*Math.PI/3, vulns: ['API Key Leak', 'Broken Auth'], nextSteps: ['Enum Endpoints', 'OAuth Abuse'] },
            { name: 'App Server', layer: 'infra', type: 'app', radius: 6, phi: 2*Math.PI/3, theta: Math.PI, vulns: ['Deserialization', 'RCE'], nextSteps: ['Gadget Chains', 'Command Inj'] },
            { name: 'Cache (Redis)', layer: 'infra', type: 'data', radius: 6, phi: Math.PI, theta: 4*Math.PI/3, vulns: ['No Auth', 'SSRF'], nextSteps: ['Key Enum', 'RCE via Lua'] },
            
            // Core Layer (inner, radius 3)
            { name: 'Database (SQL)', layer: 'core', type: 'data', radius: 3, phi: Math.PI/6, theta: Math.PI/2, vulns: ['SQLi', 'Backup Exposure'], nextSteps: ['Union Select', 'Dump Tables'] },
            { name: 'Secrets Vault', layer: 'core', type: 'secrets', radius: 3, phi: Math.PI/2, theta: Math.PI, vulns: ['Weak Encryption', 'Misconfig'], nextSteps: ['Brute Force', 'Side Channel'] },
            { name: 'User DB', layer: 'core', type: 'data', radius: 3, phi: 5*Math.PI/6, theta: 3*Math.PI/2, vulns: ['Hash Cracking', 'IDOR'], nextSteps: ['Rainbow Tables', 'Privilege Esc'] }
        ];

        // Connections: pairs of node indices for attack paths
        const connectionData = [
            [0, 3], // Firewall -> Web Server
            [1, 4], // IDS -> API
            [2, 5], // LB -> App Server
            [3, 6], // Web -> App
            [4, 7], // API -> Cache
            [5, 6], // App -> Cache
            [6, 8], // App -> User DB
            [7, 8], // Cache -> User DB
            [8, 9]  // User DB -> Secrets
        ];

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Raycaster for interactions
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0x00ff00, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x00ffff, 1, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);

            // Create layers
            createLayers();
            createNodes();
            createConnections();

            // Particles for cyber atmosphere
            createParticles();

            // Event listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('click', onMouseClick, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function createLayers() {
            // Concentric wireframe spheres for layers
            const layerRadii = { perimeter: 10, infra: 6, core: 3 };
            const layerColors = { perimeter: 0xff0000, infra: 0xffff00, core: 0x00ff00 };

            Object.keys(layerRadii).forEach(layer => {
                const geometry = new THREE.SphereGeometry(layerRadii[layer], 32, 16);
                const material = new THREE.MeshBasicMaterial({ color: layerColors[layer], wireframe: true, transparent: true, opacity: 0.3 });
                layers[layer] = new THREE.Mesh(geometry, material);
                scene.add(layers[layer]);
            });
        }

        function createNodes() {
            nodeData.forEach((data, index) => {
                // Position in 3D space
                const x = data.radius * Math.sin(data.phi) * Math.cos(data.theta);
                const y = data.radius * Math.sin(data.phi) * Math.sin(data.theta);
                const z = data.radius * Math.cos(data.phi);

                // Node geometry: glowing sphere
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: getLayerColor(data.layer),
                    emissive: getLayerColor(data.layer),
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.8
                });
                const node = new THREE.Mesh(geometry, material);
                node.position.set(x, y, z);
                node.userData = { ...data, index };
                node.castShadow = true;
                node.receiveShadow = true;
                scene.add(node);
                nodes.push(node);

                // Label (text sprite - simplified with canvas)
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = '#000';
                context.fillRect(0, 0, 256, 64);
                context.fillStyle = '#00ff00';
                context.font = 'bold 20px Courier New';
                context.fillText(data.name, 10, 40);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, y + 0.5, z);
                sprite.scale.set(2, 0.5, 1);
                scene.add(sprite);
                node.userData.label = sprite;
            });
        }

        function createConnections() {
            connectionData.forEach(([i1, i2]) => {
                const node1 = nodes[i1];
                const node2 = nodes[i2];
                const geometry = new THREE.BufferGeometry().setFromPoints([node1.position, node2.position]);
                const material = new THREE.LineBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.6 });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                connections.push(line);
            });
        }

        function createParticles() {
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCnt = 1000;
            const posArray = new Float32Array(particlesCnt * 3);
            for (let i = 0; i < particlesCnt * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 50;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.005,
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particlesMesh);
        }

        function getLayerColor(layer) {
            const colors = { perimeter: 0xff0000, infra: 0xffff00, core: 0x00ff00 };
            return colors[layer] || 0xffffff;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);
            if (intersects.length > 0) {
                const node = intersects[0].object;
                showNodeInfo(node);
                highlightNode(node);
                // Animate path from this node
                if (showPaths) animatePathFrom(node.userData.index);
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);
            // Hover effect
            nodes.forEach(n => n.material.emissiveIntensity = 0.2);
            if (intersects.length > 0) {
                intersects[0].object.material.emissiveIntensity = 0.8;
            }
        }

        function showNodeInfo(node) {
            const data = node.userData;
            document.getElementById('node-title').textContent = data.name + ' (' + data.layer.toUpperCase() + ')';
            const details = document.getElementById('node-details');
            details.innerHTML = `
                <li><strong>Type:</strong> ${data.type}</li>
                <li><strong>Vulnerabilities:</strong> ${data.vulns.join(', ')}</li>
                <li><strong>Next Steps:</strong> ${data.nextSteps.join(', ')}</li>
                <li><strong>Attack Vector:</strong> Focus here to pivot inward. Avoid distractions like unrelated endpoints.</li>
            `;
            document.getElementById('info-panel').style.display = 'block';
        }

        function highlightNode(node) {
            gsap.to(node.material, { duration: 0.5, emissiveIntensity: 1 });
            gsap.to(node.scale, { duration: 0.5, x: 1.5, y: 1.5, z: 1.5, yoyo: true, repeat: 1 });
            // Pulse label
            if (node.userData.label) {
                gsap.to(node.userData.label.scale, { duration: 0.5, x: 2.5, y: 0.75, yoyo: true, repeat: 1 });
            }
        }

        function animatePathFrom(startIndex) {
            // Simple animation: glow connections from start
            connections.forEach((conn, i) => {
                const [i1, i2] = connectionData[i];
                if (i1 === startIndex || i2 === startIndex) {
                    gsap.to(conn.material, { duration: 1, opacity: 1 });
                    gsap.to(conn.scale, { duration: 1, x: 1.2, yoyo: true, repeat: 3 });
                }
            });
        }

        function resetView() {
            controls.reset();
            document.getElementById('info-panel').style.display = 'none';
            nodes.forEach(n => {
                n.material.emissiveIntensity = 0.2;
                n.scale.set(1,1,1);
            });
        }

        function togglePaths() {
            showPaths = !showPaths;
            connections.forEach(conn => {
                conn.visible = showPaths;
                conn.material.opacity = showPaths ? 0.6 : 0;
            });
        }

        function scanForVulns() {
            if (scanning) return;
            scanning = true;
            nodes.forEach((node, i) => {
                gsap.to(node.position, {
                    duration: 0.5,
                    y: node.position.y + Math.sin(i) * 0.5,
                    yoyo: true,
                    repeat: 1,
                    delay: i * 0.1,
                    onComplete: () => {
                        scanning = false;
                        // Random vuln highlight
                        if (Math.random() > 0.5) {
                            gsap.to(node.material.color, { duration: 0.3, r: 1, g: 0, b: 0 });
                            setTimeout(() => gsap.to(node.material.color, { duration: 0.3, r: getLayerColor(node.userData.layer) / 0xffffff, g: 0, b: 0 }), 500);
                        }
                    }
                });
            });
            // Scan message
            const panel = document.getElementById('info-panel');
            panel.style.display = 'block';
            panel.innerHTML = '<h3>System Scan</h3><ul><li>Scanning for exploits...</li><li>Potential entry: Perimeter misconfigs</li><li>Path: Firewall -> Web -> DB</li><li>Stay focused: Ignore noise endpoints</li></ul>';
            setTimeout(() => { panel.style.display = 'none'; }, 3000);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Rotate layers slowly
            Object.values(layers).forEach(layer => {
                layer.rotation.y += 0.005;
            });

            // Pulse central light
            scene.children.find(c => c.type === 'PointLight').intensity = 1 + Math.sin(Date.now() * 0.001) * 0.5;

            // Animate particles
            scene.children.find(c => c.type === 'Points').rotation.y += 0.0005;

            renderer.render(scene, camera);
        }

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>

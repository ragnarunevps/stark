<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stark Globe — Pro Final (Distraction-Free)</title>
  <meta name="description" content="Stark Globe — Final distraction-free pro build with Google‑Earth style controls, starfield, pulsating core and high-fidelity visuals." />
  <style>
    :root{--bg:#000;--accent:#00ffd6;--muted:#6ef0c8}
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,ui-sans-serif,system-ui,monospace;color:var(--accent)}
    #app{position:fixed;inset:0}
    canvas{display:block;width:100%;height:100%}

    /* minimal HUD (hidden by default) */
    #hud{position:fixed;left:12px;top:12px;padding:8px 10px;border-radius:8px;background:rgba(0,0,0,0.35);backdrop-filter:blur(6px);font-size:13px;color:#bff;text-shadow:0 1px 8px rgba(0,0,0,0.6);display:none}
    #miniToggle{position:fixed;right:12px;top:12px;padding:8px;border-radius:8px;background:rgba(0,0,0,0.25);cursor:pointer;color:var(--accent);font-size:13px}
    #prompt{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,0.28);color:#9ff;font-size:12px}

    /* context overlay when inspecting (subtle) */
    #inspect{position:fixed;right:12px;bottom:12px;min-width:260px;max-width:420px;padding:10px;border-radius:8px;background:linear-gradient(180deg,rgba(0,0,0,0.45),rgba(0,0,0,0.25));border:1px solid rgba(0,255,214,0.06);display:none;color:#dff}
    #inspect h3{margin:0 0 6px;font-size:14px}
    .tiny{font-size:12px;color:#9fe}

    /* tasteful focus ring */
    .focus-ring{box-shadow:0 0 24px rgba(0,255,214,0.08);border-radius:6px}

    @media (max-width:600px){#inspect{display:none}}
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="hud">Stark Globe — Final • <span id="fps">--</span> FPS</div>
  <div id="miniToggle" title="Toggle HUD (H)">☰</div>
  <div id="prompt">Double-click a node to zoom • Right-click toggles HUD • H to hide/show</div>
  <div id="inspect"><h3 id="inName">—</h3><div id="inMeta" class="tiny">—</div></div>

  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.181.2/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/controls/OrbitControls.js';
  import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { ShaderPass } from 'https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/postprocessing/ShaderPass.js';
  import { FXAAShader } from 'https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/shaders/FXAAShader.js';

  // ---------- Scene + renderer ----------
  const container = document.getElementById('app');
  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.0025);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 18, 48);

  // controls — tuned to be like Google Earth (smooth, tilt, inertia)
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.12; controls.enablePan = true; controls.screenSpacePanning = false;
  controls.minDistance = 6; controls.maxDistance = 250; controls.maxPolarAngle = Math.PI * 0.495; // allow tilt
  controls.rotateSpeed = 0.4; controls.zoomSpeed = 0.8; controls.panSpeed = 0.6;

  // smooth zooming helper
  let targetDistance = null;
  function smoothZoomTo(dist){ targetDistance = Math.max(4, Math.min(300, dist)); }

  // ---------- postprocessing ----------
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.6, 0.35, 0.9);
  bloom.threshold = 0.12; bloom.strength = 1.4; bloom.radius = 0.6; composer.addPass(bloom);
  const fxaa = new ShaderPass(FXAAShader); fxaa.uniforms['resolution'].value.set(1/window.innerWidth, 1/window.innerHeight); composer.addPass(fxaa);

  // ---------- lighting ----------
  const hemi = new THREE.HemisphereLight(0x335577, 0x000000, 0.6); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0x9dfcff, 1.0); dir.position.set(10,20,10); scene.add(dir);
  const rim = new THREE.PointLight(0x00ffd6, 1.6, 60, 2); rim.position.set(0,0,0); scene.add(rim);

  // ---------- starfield (procedural points) ----------
  function makeStarfield(count=8000, radius=120){
    const g = new THREE.BufferGeometry(); const positions = new Float32Array(count*3); const sizes = new Float32Array(count);
    for(let i=0;i<count;i++){ const phi=Math.acos(2*Math.random()-1); const theta=2*Math.PI*Math.random(); const r = radius * (0.8 + 0.2*Math.random()); const x = r*Math.sin(phi)*Math.cos(theta); const y = r*Math.sin(phi)*Math.sin(theta); const z = r*Math.cos(phi); positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z; sizes[i]=Math.random()*2.4+0.2; }
    g.setAttribute('position', new THREE.BufferAttribute(positions,3)); g.setAttribute('size', new THREE.BufferAttribute(sizes,1));
    const mat = new THREE.PointsMaterial({ size: 1.2, sizeAttenuation: true, color: 0xffffff, transparent:true, opacity:0.9 });
    const pts = new THREE.Points(g, mat); pts.renderOrder = 0; scene.add(pts); return pts;
  }
  const stars = makeStarfield(9000,220);

  // ---------- core (heart) — layered pulsating shader-ish effect ----------
  const coreGroup = new THREE.Group(); scene.add(coreGroup);
  const coreGeo = new THREE.IcosahedronGeometry(3.6, 6);
  const coreMat = new THREE.MeshStandardMaterial({ color: 0x00ffd6, emissive:0x00a887, emissiveIntensity:1.4, roughness:0.12, metalness:0.8, transparent:true, opacity:0.98 });
  const core = new THREE.Mesh(coreGeo, coreMat); coreGroup.add(core);
  // inner glow sphere
  const glowGeo = new THREE.SphereGeometry(4.6,32,22);
  const glowMat = new THREE.MeshBasicMaterial({ color:0x00ffd6, transparent:true, opacity:0.08 });
  const glow = new THREE.Mesh(glowGeo, glowMat); coreGroup.add(glow);

  // subtle energy tendrils (sine deformed lines)
  const tendrilCount = 20; const tendrils = new THREE.Group(); coreGroup.add(tendrils);
  for(let i=0;i<tendrilCount;i++){
    const lgeo = new THREE.BufferGeometry(); const pts = new Float32Array(300*3);
    for(let j=0;j<300;j++){ pts[j*3]=0; pts[j*3+1]= (j/300)*12; pts[j*3+2]=0; }
    lgeo.setAttribute('position', new THREE.BufferAttribute(pts,3));
    const lmat = new THREE.LineBasicMaterial({ color:0x00ffd6, transparent:true, opacity:0.22 });
    const line = new THREE.Line(lgeo, lmat); line.rotation.y = Math.random()*Math.PI*2; line.rotation.x = Math.random()*0.4 - 0.2; tendrils.add(line);
  }

  // animate core pulses
  let corePulse = 0;

  // ---------- layers + nodes (high fidelity) ----------
  const LAYERS = [ {id:'perimeter', radius:28, color:0xff6655, detail:128}, {id:'infra', radius:18, color:0xffcc33, detail:96}, {id:'core', radius:9, color:0x00ffd6, detail:64} ];
  const layerGroups = {};
  LAYERS.forEach(l=>{
    const g = new THREE.Group(); g.name=l.id; scene.add(g); layerGroups[l.id]=g;
    const ringGeo = new THREE.RingGeometry(l.radius-0.12, l.radius+0.12, 256);
    const ringMat = new THREE.MeshBasicMaterial({ color: l.color, transparent:true, opacity:0.06, side:THREE.DoubleSide });
    const ring = new THREE.Mesh(ringGeo, ringMat); ring.rotation.x = Math.PI/2; g.add(ring);
    // high-res wire shell
    const shell = new THREE.Mesh(new THREE.SphereGeometry(l.radius, 120, 80), new THREE.MeshStandardMaterial({ color:l.color, transparent:true, opacity:0.04, roughness:0.9, metalness:0.1 }));
    g.add(shell);
  });

  // node defs (same schema but richer visuals)
  const NODE_DEFS = [
    {name:'Edge Firewall',layer:'perimeter',type:'defense',v:'Rule Bypass'},
    {name:'WAF',layer:'perimeter',type:'defense',v:'Rule Evasion'},
    {name:'Reverse Proxy',layer:'perimeter',type:'infra',v:'Header Injection'},
    {name:'CDN Edge',layer:'perimeter',type:'infra',v:'Cache Poison'},
    {name:'Web Cluster',layer:'infra',type:'app',v:'XSS'},
    {name:'API Gateway',layer:'infra',type:'app',v:'Auth Bypass'},
    {name:'App Server',layer:'infra',type:'app',v:'Prototype Poll'},
    {name:'Primary DB',layer:'core',type:'data',v:'SQLi'},
    {name:'Secrets Manager',layer:'core',type:'secrets',v:'Misconfig'}
  ];

  const nodes = [];
  function placeNodes(){
    const map = Object.fromEntries(LAYERS.map(l=>[l.id,l.radius]));
    for(let i=0;i<NODE_DEFS.length;i++){
      const d = NODE_DEFS[i]; const r = map[d.layer];
      // spherical distribution but biased to visible hemisphere
      const phi = Math.acos(1 - 2*Math.random()); const theta = Math.PI*2*Math.random();
      const x = r * Math.sin(phi) * Math.cos(theta); const y = (Math.random()*0.8 - 0.2) * 6; const z = r * Math.sin(phi) * Math.sin(theta);
      const geom = new THREE.SphereGeometry(0.6 + Math.random()*0.4, 24, 18);
      const mat = new THREE.MeshStandardMaterial({ color: (d.layer==='core'?0x00ffd6: (d.layer==='infra'?0xffcc33:0xff6655)), emissive:0x000000, metalness:0.7, roughness:0.18});
      const m = new THREE.Mesh(geom, mat); m.position.set(x,y,z); m.userData = d; m.userData.index = i;
      // add subtle halo
      const sprite = makeLabel(d.name);
      sprite.position.set(x, y + 1.1, z); sprite.scale.set(1.6,0.5,1);
      layerGroups[d.layer].add(m); layerGroups[d.layer].add(sprite);
      nodes.push(m);
    }
  }

  function makeLabel(text){
    const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=128; const ctx=cvs.getContext('2d');
    ctx.clearRect(0,0,cvs.width,cvs.height);
    ctx.fillStyle='rgba(0,0,0,0.0)'; ctx.fillRect(0,0,cvs.width,cvs.height);
    ctx.fillStyle='#cffff4'; ctx.font='bold 34px monospace'; ctx.fillText(text,18,78);
    const texture = new THREE.CanvasTexture(cvs); texture.encoding = THREE.sRGBEncoding; const sp = new THREE.Sprite(new THREE.SpriteMaterial({map:texture,transparent:true})); return sp;
  }

  placeNodes();

  // ---------- connections (curved, shiny) ----------
  const connections = new THREE.Group(); scene.add(connections);
  function link(a,b){
    const pa = a.position; const pb = b.position; const mid = pa.clone().lerp(pb,0.5); mid.normalize().multiplyScalar(Math.max(pa.length(), pb.length())*1.06);
    const curve = new THREE.CatmullRomCurve3([pa, mid, pb]); const pts = curve.getPoints(64);
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({ color:0x00ffd6, linewidth:2, transparent:true, opacity:0.16 });
    const line = new THREE.Line(geo, mat); connections.add(line);
  }
  for(let i=0;i<nodes.length-1;i++){ link(nodes[i], nodes[i+1]); }

  // ---------- raycast + interactions ----------
  const ray = new THREE.Raycaster(); const mouse = new THREE.Vector2(); let hovered=null;
  function onMove(e){ mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = - (e.clientY / window.innerHeight) * 2 + 1; }
  window.addEventListener('pointermove', onMove);

  // double-click to zoom like Google Earth
  window.addEventListener('dblclick', e=>{
    ray.setFromCamera(mouse, camera);
    const inter = ray.intersectObjects(nodes, false);
    if(inter.length){ const n = inter[0].object; focusOnNode(n); }
    else{ // zoom out
      gsapZoomTo(48, new THREE.Vector3(0,6,0));
    }
  });

  // right-click toggles HUD
  window.addEventListener('contextmenu', e=>{ e.preventDefault(); toggleHUD(); });

  // keyboard H toggles HUD
  window.addEventListener('keydown', e=>{ if(e.key==='h' || e.key==='H') toggleHUD(); if(e.key==='Escape'){ hideInspect(); } });

  // double tap on touch devices -> handled by dblclick

  // focus routine
  import('https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js').then(({gsap})=>{
    window._gsap = gsap; // keep reference
  });

  function gsapZoomTo(dist, lookAt){
    const gsap = window._gsap; if(!gsap) return; gsap.to(camera.position, { duration: 1.1, x: camera.position.x * (dist/camera.position.distanceTo(new THREE.Vector3(0,0,0))), y: camera.position.y * (dist/camera.position.distanceTo(new THREE.Vector3(0,0,0))), z: camera.position.z * (dist/camera.position.distanceTo(new THREE.Vector3(0,0,0))), ease: 'power2.inOut' });
    if(lookAt) gsap.to({}, { duration: 1.05, onUpdate: ()=>{ camera.lookAt(lookAt); } });
  }

  function focusOnNode(node){
    const pos = node.position.clone(); const dir = pos.clone().normalize().multiplyScalar(6); const dest = pos.clone().add(dir);
    const gsap = window._gsap; if(!gsap) return; gsap.to(camera.position, { x: dest.x, y: dest.y + 1.2, z: dest.z, duration: 1.1, ease: 'power2.inOut' });
    gsap.to(controls.target, { x: pos.x, y: pos.y, z: pos.z, duration: 1.1, ease: 'power2.inOut' });
    showInspect(node.userData);
  }

  function showInspect(data){ const el = document.getElementById('inspect'); document.getElementById('inName').textContent = data.name; document.getElementById('inMeta').textContent = `${data.type} • layer: ${data.layer} • vuln: ${data.v||'—'}`; el.style.display='block'; el.classList.add('focus-ring'); }
  function hideInspect(){ const el = document.getElementById('inspect'); el.style.display='none'; }
  function toggleHUD(){ const hud = document.getElementById('hud'); hud.style.display = hud.style.display === 'none' || hud.style.display === '' ? 'block':'none'; }

  document.getElementById('miniToggle').addEventListener('click', toggleHUD);

  // ---------- subtle animations ----------
  let last = performance.now(); function updateTendrils(time){ tendrils.children.forEach((ln,i)=>{
    const pos = ln.geometry.attributes.position.array; for(let j=0;j<300;j++){ const idx=j*3; const baseY = (j/300)*12; const wob = Math.sin(time*0.002 + i*0.6 + j*0.12) * (0.18 + (j/300)*0.8); pos[idx] = wob * Math.cos(i+j) ; pos[idx+1] = baseY; pos[idx+2] = wob * Math.sin(i+j);
    }
    ln.geometry.attributes.position.needsUpdate = true;
  }); }

  // ---------- FPS HUD ----------
  const fpsEl = document.getElementById('fps'); let fpsCount = {last: performance.now(), frames:0, fps:60};
  function tickFPS(){ fpsCount.frames++; const now = performance.now(); if(now - fpsCount.last > 500){ fpsCount.fps = Math.round(fpsCount.frames*1000/(now-fpsCount.last)); fpsCount.last = now; fpsCount.frames=0; fpsEl.textContent = fpsCount.fps; } }

  // ---------- animation loop ----------
  function animate(){ requestAnimationFrame(animate);
    // smooth zoom to targetDistance
    if(targetDistance){ const cur = camera.position.length(); const diff = targetDistance - cur; if(Math.abs(diff) > 0.05){ camera.position.multiplyScalar(1 + diff*0.02); } else { targetDistance = null; } }

    // pulsate core
    corePulse += 0.03; const pulse = 1 + Math.sin(corePulse)*0.14; core.scale.setScalar(pulse); glow.scale.setScalar(1 + Math.sin(corePulse*0.6)*0.08);
    rim.intensity = 0.4 + Math.abs(Math.sin(corePulse*0.7))*1.6; core.material.emissiveIntensity = 0.8 + Math.abs(Math.sin(corePulse))*1.2;

    // rotate layers slowly
    Object.values(layerGroups).forEach((g,idx)=> g.rotation.y += 0.0008 * (idx+1));

    // tendrils animation
    updateTendrils(performance.now());

    // raycast hover
    ray.setFromCamera(mouse, camera);
    const hits = ray.intersectObjects(nodes, false);
    if(hits.length){ if(hovered !== hits[0].object){ if(hovered) hovered.material.emissive.setHex(0x000000); hovered = hits[0].object; hovered.material.emissive.setHex(0x002233); document.body.style.cursor = 'pointer'; } }
    else{ if(hovered){ hovered.material.emissive.setHex(0x000000); hovered = null; document.body.style.cursor = ''; } }

    controls.update(); composer.render(); tickFPS();
  }

  animate();

  // ---------- responsiveness ----------
  window.addEventListener('resize', ()=>{ renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); fxaa.uniforms['resolution'].value.set(1/window.innerWidth,1/window.innerHeight); });

  // ---------- small helpers for export and final-touch: PNG export via key P ----------
  window.addEventListener('keydown', e=>{ if(e.key==='p'||e.key==='P'){ renderer.domElement.toBlob(b=>{ const url = URL.createObjectURL(b); const a=document.createElement('a'); a.href=url; a.download='stark_globe_final.png'; a.click(); URL.revokeObjectURL(url); }); } });

  // expose scene for integration
  window.starkFinal = { scene, camera, renderer, nodes, layerGroups };

  </script>
</body>
</html>

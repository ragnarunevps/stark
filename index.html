<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stark Globe: Ultimate Ethical Hacking System Navigator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            color: #00aa00;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 350px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #00aa00;
            padding: 15px;
            border-radius: 5px;
            display: none;
            z-index: 100;
            max-height: 500px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 170, 0, 0.2);
        }
        #info-panel h3 {
            margin: 0 0 10px 0;
            color: #00ff41;
            border-bottom: 1px solid #00aa00;
            padding-bottom: 5px;
        }
        #info-panel ul {
            margin: 0;
            padding-left: 20px;
        }
        #info-panel li {
            margin-bottom: 8px;
            list-style-type: none;
            position: relative;
            padding-left: 15px;
        }
        #info-panel li:before {
            content: '▸';
            position: absolute;
            left: 0;
            color: #00aa00;
        }
        #layer-vulns {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            margin-top: 10px;
            border-radius: 3px;
        }
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #00aa00;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00aa00;
            font-size: 18px;
            z-index: 200;
            text-align: center;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #00aa00;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        button {
            background: #0a0a0a;
            color: #00aa00;
            border: 1px solid #00aa00;
            padding: 8px 12px;
            margin: 3px;
            cursor: pointer;
            border-radius: 3px;
            font-family: inherit;
            transition: all 0.3s;
        }
        button:hover {
            background: #00aa00;
            color: #0a0a0a;
            box-shadow: 0 0 10px rgba(0, 170, 0, 0.5);
        }
        #search-input {
            background: #0a0a0a;
            color: #00aa00;
            border: 1px solid #00aa00;
            padding: 5px;
            margin: 5px;
            border-radius: 3px;
            font-family: inherit;
        }
        #scan-results {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #ff4444;
            padding: 20px;
            border-radius: 5px;
            display: none;
            z-index: 150;
            max-width: 600px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading">Initializing Stark Globe... Neural scan in progress... <br><span style="font-size:14px;">Establishing secure orbital view...</span></div>
    <div id="info-panel">
        <h3 id="node-title">Node Intel</h3>
        <ul id="node-details"></ul>
        <div id="layer-vulns">
            <h4>Layer Loopholes</h4>
            <ul id="layer-loopholes"></ul>
        </div>
    </div>
    <div id="legend">
        <strong>Orbital Layers:</strong><br>
        <span style="color:#cc0000">● Perimeter (DMZ)</span><br>
        <span style="color:#ccaa00">● Infrastructure</span><br>
        <span style="color:#00aa00">● Core Systems</span><br>
        <span style="color:#0066cc">● Pivot Vectors (Lines)</span><br>
        <strong>Status:</strong> <span id="vuln-count">0</span> active exploits detected
    </div>
    <div id="controls">
        <input type="text" id="search-input" placeholder="Search Node..." onkeyup="searchNodes(event)">
        <br>
        <button onclick="resetView()">Reset Orbit</button>
        <button onclick="togglePaths()">Toggle Vectors</button>
        <button onclick="explodeView()">Explode Layers</button>
        <button onclick="simulateAttack()">Simulate Breach</button>
        <button onclick="scanForVulns()">Deep Scan</button>
    </div>
    <div id="scan-results">
        <h3>Scan Complete</h3>
        <div id="results-list"></div>
        <button onclick="closeScan()">Acknowledge</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let layers = {}; // Store layer groups
        let nodes = []; // All interactive nodes
        let connections = []; // Line segments for paths
        let showPaths = true;
        let exploded = false;
        let scanning = false;
        let vulnCount = 0;

        // Expanded Node data with detailed vulns and layer-specific loopholes
        const layerLoopholes = {
            perimeter: [
                'Firewall rule misconfigurations allowing unauthorized inbound traffic.',
                'IDS/IPS signature gaps exploitable via polymorphic payloads.',
                'DDoS mitigation bypass through slowloris or application-layer floods.',
                'VPN endpoint weak ciphers or credential stuffing risks.',
                'Perimeter honeypots misidentified as real assets, leading to false positives.'
            ],
            infra: [
                'OWASP Top 10: Injection flaws in web apps (SQLi, command injection).',
                'Broken access control allowing horizontal privilege escalation.',
                'Cryptographic failures like weak TLS configs or hardcoded secrets.',
                'API endpoint enumeration and rate-limit bypass.',
                'Supply chain attacks via third-party libraries (e.g., Log4Shell).'
            ],
            core: [
                'Database privilege abuse and blind SQL injection.',
                'Kernel-level exploits for local privilege escalation (e.g., Dirty COW).',
                'Secrets management failures (e.g., exposed AWS keys in env vars).',
                'Lateral movement via RDP/SSH weak auth or pass-the-hash.',
                'Data exfiltration channels hidden in DNS tunneling or covert channels.'
            ]
        };

        const nodeData = [
            // Perimeter Layer (outer, radius 12) - DMZ
            { name: 'Edge Firewall', layer: 'perimeter', type: 'defense', radius: 12, phi: 0, theta: 0, vulns: ['Rule Bypass', 'Stateful Inspection Flaw', 'NAT Traversal'], nextSteps: ['Nmap Stealth Scan', 'Hping3 Flood'], difficulty: 3 },
            { name: 'WAF (ModSec)', layer: 'perimeter', type: 'defense', radius: 12, phi: Math.PI/6, theta: Math.PI/2, vulns: ['Custom Rule Evasion', 'False Negatives'], nextSteps: ['Payload Obfuscation', 'Chaining Attacks'], difficulty: 4 },
            { name: 'Reverse Proxy', layer: 'perimeter', type: 'infra', radius: 12, phi: Math.PI/3, theta: Math.PI, vulns: ['Header Injection', 'Path Traversal'], nextSteps: ['Burp Suite Proxy', 'DirBuster'], difficulty: 2 },
            { name: 'CDN Edge', layer: 'perimeter', type: 'infra', radius: 12, phi: Math.PI/2, theta: 3*Math.PI/2, vulns: ['Cache Poisoning', 'Origin Pull Bypass'], nextSteps: ['DNS Spoof', 'BOLA in APIs'], difficulty: 5 },
            
            // Infrastructure Layer (middle, radius 7)
            { name: 'Web Cluster (Nginx)', layer: 'infra', type: 'app', radius: 7, phi: 0, theta: Math.PI/4, vulns: ['XSS Reflected/Stored', 'CSRF Token Bypass'], nextSteps: ['XSStrike', 'BeEF Framework'], difficulty: 2 },
            { name: 'API Gateway (Kong)', layer: 'infra', type: 'app', radius: 7, phi: Math.PI/4, theta: 3*Math.PI/4, vulns: ['GraphQL Introspection', 'Broken Object Level Auth'], nextSteps: ['Postman Enum', 'JWT Forgery'], difficulty: 4 },
            { name: 'App Servers (Node.js)', layer: 'infra', type: 'app', radius: 7, phi: Math.PI/2, theta: Math.PI, vulns: ['Prototype Pollution', 'Deserialization Gadgets'], nextSteps: ['ysoserial', 'NoSQL Injection'], difficulty: 3 },
            { name: 'Message Queue (RabbitMQ)', layer: 'infra', type: 'data', radius: 7, phi: 3*Math.PI/4, theta: 5*Math.PI/4, vulns: ['Unauth Access', 'Queue Poisoning'], nextSteps: ['RABBit Footprint', 'DLQ Exploitation'], difficulty: 5 },
            { name: 'Cache Layer (Memcached)', layer: 'infra', type: 'data', radius: 7, phi: Math.PI, theta: 7*Math.PI/4, vulns: ['Amplification DDoS', 'No Auth'], nextSteps: ['Memcrashed', 'Key Brute'], difficulty: 1 },
            
            // Core Layer (inner, radius 4)
            { name: 'Primary DB (PostgreSQL)', layer: 'core', type: 'data', radius: 4, phi: Math.PI/6, theta: Math.PI/2, vulns: ['SQLi Time-Based', 'Privilege Escalation'], nextSteps: ['SQLMap', 'pg_dump Abuse'], difficulty: 4 },
            { name: 'Secrets Manager (Vault)', layer: 'core', type: 'secrets', radius: 4, phi: Math.PI/3, theta: Math.PI, vulns: ['Policy Misconfig', 'Seal Bypass'], nextSteps: ['Vault CLI Pivot', 'Token Replay'], difficulty: 6 },
            { name: 'Auth Server (LDAP)', layer: 'core', type: 'auth', radius: 4, phi: Math.PI/2, theta: 3*Math.PI/2, vulns: ['Pass-the-Ticket', 'Kerberoasting'], nextSteps: ['Mimikatz', 'BloodHound'], difficulty: 5 },
            { name: 'File Store (S3)', layer: 'core', type: 'data', radius: 4, phi: 2*Math.PI/3, theta: 0, vulns: ['Bucket Perms', 'Shadow Copies'], nextSteps: ['AWS CLI Enum', 'Pacu Framework'], difficulty: 3 },
            { name: 'Monitoring (ELK)', layer: 'core', type: 'log', radius: 4, phi: 5*Math.PI/6, theta: Math.PI/2, vulns: ['Log Injection', 'Kibana RCE'], nextSteps: ['ElastAlert Abuse', 'KQL Injection'], difficulty: 4 }
        ];

        // Expanded Connections with difficulties
        const connectionData = [
            [0, 4], [1, 5], [2, 4], [3, 5], // Perimeter to Infra
            [4, 6], [5, 6], [4, 7], [6, 8], [7, 9], // Infra internals
            [6, 10], [8, 11], [9, 12], [10, 13], [11, 14] // Core pivots
        ];

        function init() {
            try {
                console.log('Starting Stark Globe init...');
                if (typeof THREE === 'undefined') throw new Error('Three.js not loaded');
                console.log('Three.js loaded:', THREE.REVISION);

                if (typeof THREE.OrbitControls === 'undefined') throw new Error('OrbitControls not loaded');
                console.log('OrbitControls loaded');

                // Scene setup - Darker, more atmospheric
                scene = new THREE.Scene();
                scene.fog = new THREE.Fog(0x0a0a0a, 5, 60);
                console.log('Scene created');

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 25);
                console.log('Camera created');

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x0a0a0a);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);
                console.log('Renderer created');

                // Controls with limits
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 5;
                controls.maxDistance = 50;
                console.log('Controls created');

                // Raycaster
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                console.log('Raycaster created');

                // Subtle Lighting
                const ambientLight = new THREE.AmbientLight(0x002200, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0x00aa00, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0x004400, 0.5, 100);
                pointLight.position.set(0, 0, 0);
                scene.add(pointLight);
                console.log('Lighting added');

                // Create everything
                createLayers();
                createNodes();
                createConnections();
                createAdvancedParticles();
                createHolographicEffects();
                console.log('All objects created');

                // Events
                window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('click', onMouseClick, false);
                renderer.domElement.addEventListener('mousemove', onMouseMove, false);

                document.getElementById('loading').style.display = 'none';
                animate();
                updateVulnCount();
                console.log('Stark Globe initialized successfully. Ready for orbital insertion.');
            } catch (error) {
                console.error('Init error details:', error);
                document.getElementById('loading').innerHTML += '<br><span style="color:#ff4444;">Init failed—check console for details.</span>';
            }
        }

        function createLayers() {
            const layerRadii = { perimeter: 12, infra: 7, core: 4 };
            const layerColors = { perimeter: 0x440000, infra: 0x444400, core: 0x004400 }; // Darker tones

            Object.keys(layerRadii).forEach(layer => {
                const geometry = new THREE.SphereGeometry(layerRadii[layer], 64, 32); // Higher res for smoothness
                const material = new THREE.MeshBasicMaterial({ 
                    color: layerColors[layer], 
                    wireframe: true, 
                    transparent: true, 
                    opacity: 0.15, // Much subtler
                    linewidth: 0.5 // Thinner lines
                });
                layers[layer] = new THREE.Group(); // Group for explosion
                const sphere = new THREE.Mesh(geometry, material);
                layers[layer].add(sphere);
                scene.add(layers[layer]);
            });
        }

        function createNodes() {
            nodeData.forEach((data, index) => {
                const x = data.radius * Math.sin(data.phi) * Math.cos(data.theta);
                const y = data.radius * Math.sin(data.phi) * Math.sin(data.theta);
                const z = data.radius * Math.cos(data.phi);

                // Node: Icosahedron for tech feel, subtle glow
                const geometry = new THREE.IcosahedronGeometry(0.25, 1);
                const material = new THREE.MeshPhongMaterial({ 
                    color: getLayerColor(data.layer),
                    emissive: getLayerColor(data.layer) * 0.1, // Very low emissive
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.9,
                    shininess: 100
                });
                const node = new THREE.Mesh(geometry, material);
                node.position.set(x, y, z);
                node.userData = { ...data, index, originalPos: new THREE.Vector3(x, y, z) };
                node.castShadow = true;
                node.receiveShadow = true;
                layers[data.layer].add(node); // Add to layer group
                nodes.push(node);

                // Enhanced label with glow
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'rgba(10,10,10,0.8)';
                context.fillRect(0, 0, 256, 64);
                context.strokeStyle = '#00aa00';
                context.lineWidth = 2;
                context.strokeRect(0, 0, 256, 64);
                context.fillStyle = '#00aa00';
                context.font = 'bold 16px Courier New';
                context.fillText(data.name, 10, 40);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(node.position);
                sprite.position.y += 0.6;
                sprite.scale.set(2.5, 0.6, 1);
                layers[data.layer].add(sprite);
                node.userData.label = sprite;
            });
        }

        function createConnections() {
            connectionData.forEach(([i1, i2]) => {
                const node1 = nodes[i1];
                const node2 = nodes[i2];
                const points = [];
                points.push(node1.position.clone());
                points.push(node2.position.clone());
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x003366, 
                    transparent: true, 
                    opacity: 0.4, // Subtler
                    linewidth: 1
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                line.userData = { nodes: [node1, node2], difficulty: Math.max(nodeData[i1].difficulty, nodeData[i2].difficulty) };
                connections.push(line);
            });
        }

        function createAdvancedParticles() {
            // Multi-layer particles for depth
            for (let i = 0; i < 3; i++) {
                const particlesGeometry = new THREE.BufferGeometry();
                const particlesCnt = 2000;
                const posArray = new Float32Array(particlesCnt * 3);
                const velArray = new Float32Array(particlesCnt * 3);
                for (let j = 0; j < particlesCnt * 3; j += 3) {
                    const radius = 5 + i * 10;
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI * 2;
                    posArray[j] = radius * Math.sin(phi) * Math.cos(theta);
                    posArray[j+1] = radius * Math.sin(phi) * Math.sin(theta);
                    posArray[j+2] = radius * Math.cos(phi);
                    velArray[j] = (Math.random() - 0.5) * 0.01;
                    velArray[j+1] = (Math.random() - 0.5) * 0.01;
                    velArray[j+2] = (Math.random() - 0.5) * 0.01;
                }
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                particlesGeometry.setAttribute('velocity', new THREE.BufferAttribute(velArray, 3));
                const particlesMaterial = new THREE.PointsMaterial({
                    size: 0.02,
                    color: 0x002200,
                    transparent: true,
                    opacity: 0.3
                });
                const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
                particlesMesh.userData = { type: 'particles', positions: posArray, velocities: velArray };
                scene.add(particlesMesh);
            }
        }

        function createHolographicEffects() {
            // Central holographic core
            const coreGeometry = new THREE.TorusGeometry(1, 0.3, 16, 100);
            const coreMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x004400, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            scene.add(core);
        }

        function getLayerColor(layer) {
            const colors = { perimeter: 0xcc0000, infra: 0xccaa00, core: 0x00aa00 };
            return colors[layer] || 0x666666;
        }

        function getRGBFromColor(colorHex) {
            return {
                r: (colorHex >> 16) / 255,
                g: ((colorHex >> 8) & 0xff) / 255,
                b: (colorHex & 0xff) / 255
            };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);
            if (intersects.length > 0) {
                const node = intersects[0].object;
                showNodeInfo(node);
                highlightNode(node);
                if (showPaths) animatePathFrom(node.userData.index);
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);
            nodes.forEach(n => n.material.emissiveIntensity = 0.1);
            if (intersects.length > 0) {
                intersects[0].object.material.emissiveIntensity = 0.3;
            }
        }

        function showNodeInfo(node) {
            const data = node.userData;
            document.getElementById('node-title').textContent = data.name + ' [' + data.layer.toUpperCase() + ']';
            const details = document.getElementById('node-details');
            details.innerHTML = `
                <li><strong>Type:</strong> ${data.type.toUpperCase()}</li>
                <li><strong>Key Vulns:</strong> ${data.vulns.join(' | ')}</li>
                <li><strong>Next Vectors:</strong> ${data.nextSteps.join(' | ')}</li>
                <li><strong>Difficulty:</strong> ${data.difficulty}/10</li>
                <li><strong>Guidance:</strong> Focus on ${data.layer} layer; ignore peripheral noise like unrelated APIs.</li>
            `;
            const loopholes = document.getElementById('layer-loopholes');
            loopholes.innerHTML = layerLoopholes[data.layer].map(v => `<li>${v}</li>`).join('');
            document.getElementById('info-panel').style.display = 'block';
        }

        function highlightNode(node) {
            gsap.to(node.material, { duration: 0.8, emissiveIntensity: 0.5, yoyo: true, repeat: 1 });
            gsap.to(node.scale, { duration: 0.8, x: 1.3, y: 1.3, z: 1.3, yoyo: true, repeat: 1 });
            if (node.userData.label) {
                gsap.to(node.userData.label.scale, { duration: 0.8, x: 3, y: 0.8, yoyo: true, repeat: 1 });
            }
        }

        function animatePathFrom(startIndex) {
            connections.forEach((conn, i) => {
                const [i1, i2] = connectionData[i];
                if (i1 === startIndex || i2 === startIndex) {
                    gsap.to(conn.material, { duration: 1.5, opacity: 0.8 });
                    gsap.to(conn.scale, { duration: 1.5, z: 1.5, yoyo: true, repeat: 2 });
                    // Color shift based on difficulty
                    const color = conn.userData.difficulty > 4 ? 0xff4444 : 0x00aa00;
                    const rgb = getRGBFromColor(color);
                    gsap.to(conn.material.color, { duration: 0.5, ...rgb, yoyo: true, repeat: 1 });
                }
            });
        }

        function resetView() {
            controls.reset();
            document.getElementById('info-panel').style.display = 'none';
            nodes.forEach(n => {
                n.material.emissiveIntensity = 0.1;
                n.scale.set(1,1,1);
            });
            if (exploded) explodeView(); // Collapse if exploded
        }

        function togglePaths() {
            showPaths = !showPaths;
            connections.forEach(conn => conn.visible = showPaths);
        }

        function explodeView() {
            exploded = !exploded;
            const offset = exploded ? 5 : 0;
            Object.keys(layers).forEach(layer => {
                gsap.to(layers[layer].position, {
                    duration: 1.5,
                    x: layer === 'perimeter' ? offset : 0,
                    y: layer === 'infra' ? offset : 0,
                    z: layer === 'core' ? -offset : 0,
                    ease: "power2.inOut"
                });
            });
            nodes.forEach(node => {
                gsap.to(node.position, {
                    duration: 1.5,
                    x: node.position.x * (1 + offset / node.userData.radius),
                    y: node.position.y * (1 + offset / node.userData.radius),
                    z: node.position.z * (1 + offset / node.userData.radius),
                    ease: "power2.inOut"
                });
            });
        }

        function simulateAttack() {
            // Animate a full breach path
            const breachPath = [0, 4, 6, 10]; // Example path
            breachPath.forEach((idx, step) => {
                setTimeout(() => {
                    const node = nodes[idx];
                    gsap.to(node.material, { duration: 1, emissiveIntensity: 1 });
                    const vulnRGB = getRGBFromColor(0xff4444);
                    gsap.to(node.material.color, { duration: 1, ...vulnRGB });
                    gsap.to(node.scale, { duration: 1, x: 2, y: 2, z: 2, yoyo: true, repeat: 1 });
                }, step * 1000);
            });
            // Sound cue simulation (Web Audio)
            if (typeof AudioContext !== 'undefined') {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                oscillator.connect(audioCtx.destination);
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.start();
                setTimeout(() => oscillator.stop(), 3000);
            }
        }

        function searchNodes(event) {
            const query = event.target.value.toLowerCase();
            nodes.forEach(node => {
                const visible = node.userData.name.toLowerCase().includes(query) || query === '';
                node.visible = visible;
                node.userData.label.visible = visible;
                // Hide connected lines if nodes hidden
                connections.forEach(conn => {
                    const [n1, n2] = conn.userData.nodes;
                    conn.visible = showPaths && n1.visible && n2.visible;
                });
            });
        }

        function scanForVulns() {
            if (scanning) return;
            scanning = true;
            vulnCount = 0;
            const results = [];
            nodes.forEach((node, i) => {
                const hasVuln = Math.random() > 0.3; // 70% chance
                if (hasVuln) {
                    vulnCount++;
                    const vulnRGB = getRGBFromColor(0xff4444);
                    gsap.to(node.material, {
                        duration: 0.5,
                        emissiveIntensity: 0.8,
                        delay: i * 0.05
                    });
                    gsap.to(node.material.color, {
                        duration: 0.5,
                        ...vulnRGB,
                        delay: i * 0.05
                    });
                    results.push(`${node.userData.name}: ${node.userData.vulns[0]} detected`);
                    setTimeout(() => {
                        const originalRGB = getRGBFromColor(getLayerColor(node.userData.layer));
                        gsap.to(node.material, { duration: 1, emissiveIntensity: 0.1 });
                        gsap.to(node.material.color, { duration: 1, ...originalRGB });
                    }, 500 + i * 50);
                }
            });
            updateVulnCount();
            document.getElementById('results-list').innerHTML = results.slice(0, 5).join('<br>') + (results.length > 5 ? '<br>... and more' : '');
            document.getElementById('scan-results').style.display = 'block';
            setTimeout(() => { document.getElementById('scan-results').style.display = 'none'; scanning = false; }, 5000);
        }

        function closeScan() {
            document.getElementById('scan-results').style.display = 'none';
        }

        function updateVulnCount() {
            document.getElementById('vuln-count').textContent = vulnCount;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Slow layer rotation
            Object.values(layers).forEach(layer => layer.rotation.y += 0.002);

            // Subtle particle movement (throttled for perf)
            if (Date.now() % 2 === 0) { // Every other frame
                scene.traverse(obj => {
                    if (obj.userData && obj.userData.type === 'particles') {
                        const positions = obj.geometry.attributes.position.array;
                        const velocities = obj.geometry.attributes.velocity.array;
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] += velocities[i];
                            positions[i+1] += velocities[i+1];
                            positions[i+2] += velocities[i+2];
                            // Wrap around
                            if (Math.abs(positions[i]) > 30) velocities[i] *= -1;
                            if (Math.abs(positions[i+1]) > 30) velocities[i+1] *= -1;
                            if (Math.abs(positions[i+2]) > 30) velocities[i+2] *= -1;
                        }
                        obj.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }

            // Holographic core pulse
            const core = scene.children.find(c => c.geometry && c.geometry.type === 'TorusGeometry');
            if (core) {
                core.rotation.x += 0.01;
                core.rotation.y += 0.005;
                core.material.opacity = 0.4 + Math.sin(Date.now() * 0.001) * 0.2;
            }

            // Central light subtle pulse
            const pointLight = scene.children.find(c => c.type === 'PointLight');
            if (pointLight) pointLight.intensity = 0.5 + Math.sin(Date.now() * 0.0005) * 0.2;

            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>

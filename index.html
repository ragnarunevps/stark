<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stark Globe: Ultimate Ethical Hacking System Navigator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            color: #00aa00;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 350px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #00aa00;
            padding: 15px;
            border-radius: 5px;
            display: none;
            z-index: 100;
            max-height: 500px;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 170, 0, 0.2);
        }
        #info-panel h3 {
            margin: 0 0 10px 0;
            color: #00ff41;
            border-bottom: 1px solid #00aa00;
            padding-bottom: 5px;
        }
        #info-panel ul {
            margin: 0;
            padding-left: 20px;
        }
        #info-panel li {
            margin-bottom: 8px;
            list-style-type: none;
            position: relative;
            padding-left: 15px;
        }
        #info-panel li:before {
            content: '▸';
            position: absolute;
            left: 0;
            color: #00aa00;
        }
        #layer-vulns {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            margin-top: 10px;
            border-radius: 3px;
        }
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #00aa00;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00aa00;
            font-size: 18px;
            z-index: 200;
            text-align: center;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #00aa00;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        button {
            background: #0a0a0a;
            color: #00aa00;
            border: 1px solid #00aa00;
            padding: 8px 12px;
            margin: 3px;
            cursor: pointer;
            border-radius: 3px;
            font-family: inherit;
            transition: all 0.3s;
        }
        button:hover {
            background: #00aa00;
            color: #0a0a0a;
            box-shadow: 0 0 10px rgba(0, 170, 0, 0.5);
        }
        #search-input {
            background: #0a0a0a;
            color: #00aa00;
            border: 1px solid #00aa00;
            padding: 5px;
            margin: 5px;
            border-radius: 3px;
            font-family: inherit;
        }
        #scan-results {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #ff4444;
            padding: 20px;
            border-radius: 5px;
            display: none;
            z-index: 150;
            max-width: 600px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading">Initializing Stark Globe... Neural scan in progress... <br><span style="font-size:14px;">Establishing secure orbital view...</span></div>
    <div id="info-panel">
        <h3 id="node-title">Node Intel</h3>
        <ul id="node-details"></ul>
        <div id="layer-vulns">
            <h4>Layer Loopholes</h4>
            <ul id="layer-loopholes"></ul>
        </div>
    </div>
    <div id="legend">
        <strong>Orbital Layers:</strong><br>
        <span style="color:#cc0000">● Perimeter (DMZ)</span><br>
        <span style="color:#ccaa00">● Infrastructure</span><br>
        <span style="color:#00aa00">● Core Systems</span><br>
        <span style="color:#0066cc">● Pivot Vectors (Lines)</span><br>
        <strong>Status:</strong> <span id="vuln-count">0</span> active exploits detected
    </div>
    <div id="controls">
        <input type="text" id="search-input" placeholder="Search Node..." onkeyup="searchNodes(event)">
        <br>
        <button onclick="resetView()">Reset Orbit</button>
        <button onclick="togglePaths()">Toggle Vectors</button>
        <button onclick="explodeView()">Explode Layers</button>
        <button onclick="simulateAttack()">Simulate Breach</button>
        <button onclick="scanForVulns()">Deep Scan</button>
    </div>
    <div id="scan-results">
        <h3>Scan Complete</h3>
        <div id="results-list"></div>
        <button onclick="closeScan()">Acknowledge</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.181.2/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.181.2/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Global variables (exposed to window for onclick etc.)
        window.scene = null;
        window.camera = null;
        window.renderer = null;
        window.controls = null;
        window.composer = null;
        window.raycaster = null;
        window.mouse = null;
        window.layers = {};
        window.nodes = [];
        window.connections = [];
        window.showPaths = true;
        window.exploded = false;
        window.scanning = false;
        window.vulnCount = 0;

        // Expanded Node data with detailed vulns and layer-specific loopholes
        const layerLoopholes = {
            perimeter: [
                'Firewall rule misconfigurations allowing unauthorized inbound traffic.',
                'IDS/IPS signature gaps exploitable via polymorphic payloads.',
                'DDoS mitigation bypass through slowloris or application-layer floods.',
                'VPN endpoint weak ciphers or credential stuffing risks.',
                'Perimeter honeypots misidentified as real assets, leading to false positives.'
            ],
            infra: [
                'OWASP Top 10: Injection flaws in web apps (SQLi, command injection).',
                'Broken access control allowing horizontal privilege escalation.',
                'Cryptographic failures like weak TLS configs or hardcoded secrets.',
                'API endpoint enumeration and rate-limit bypass.',
                'Supply chain attacks via third-party libraries (e.g., Log4Shell).'
            ],
            core: [
                'Database privilege abuse and blind SQL injection.',
                'Kernel-level exploits for local privilege escalation (e.g., Dirty COW).',
                'Secrets management failures (e.g., exposed AWS keys in env vars).',
                'Lateral movement via RDP/SSH weak auth or pass-the-hash.',
                'Data exfiltration channels hidden in DNS tunneling or covert channels.'
            ]
        };

        const nodeData = [
            // Perimeter Layer (outer, radius 12) - DMZ
            { name: 'Edge Firewall', layer: 'perimeter', type: 'defense', radius: 12, phi: 0, theta: 0, vulns: ['Rule Bypass', 'Stateful Inspection Flaw', 'NAT Traversal'], nextSteps: ['Nmap Stealth Scan', 'Hping3 Flood'], difficulty: 3 },
            { name: 'WAF (ModSec)', layer: 'perimeter', type: 'defense', radius: 12, phi: Math.PI/6, theta: Math.PI/2, vulns: ['Custom Rule Evasion', 'False Negatives'], nextSteps: ['Payload Obfuscation', 'Chaining Attacks'], difficulty: 4 },
            { name: 'Reverse Proxy', layer: 'perimeter', type: 'infra', radius: 12, phi: Math.PI/3, theta: Math.PI, vulns: ['Header Injection', 'Path Traversal'], nextSteps: ['Burp Suite Proxy', 'DirBuster'], difficulty: 2 },
            { name: 'CDN Edge', layer: 'perimeter', type: 'infra', radius: 12, phi: Math.PI/2, theta: 3*Math.PI/2, vulns: ['Cache Poisoning', 'Origin Pull Bypass'], nextSteps: ['DNS Spoof', 'BOLA in APIs'], difficulty: 5 },
            
            // Infrastructure Layer (middle, radius 7)
            { name: 'Web Cluster (Nginx)', layer: 'infra', type: 'app', radius: 7, phi: 0, theta: Math.PI/4, vulns: ['XSS Reflected/Stored', 'CSRF Token Bypass'], nextSteps: ['XSStrike', 'BeEF Framework'], difficulty: 2 },
            { name: 'API Gateway (Kong)', layer: 'infra', type: 'app', radius: 7, phi: Math.PI/4, theta: 3*Math.PI/4, vulns: ['GraphQL Introspection', 'Broken Object Level Auth'], nextSteps: ['Postman Enum', 'JWT Forgery'], difficulty: 4 },
            { name: 'App Servers (Node.js)', layer: 'infra', type: 'app', radius: 7, phi: Math.PI/2, theta: Math.PI, vulns: ['Prototype Pollution', 'Deserialization Gadgets'], nextSteps: ['ysoserial', 'NoSQL Injection'], difficulty: 3 },
            { name: 'Message Queue (RabbitMQ)', layer: 'infra', type: 'data', radius: 7, phi: 3*Math.PI/4, theta: 5*Math.PI/4, vulns: ['Unauth Access', 'Queue Poisoning'], nextSteps: ['RABBit Footprint', 'DLQ Exploitation'], difficulty: 5 },
            { name: 'Cache Layer (Memcached)', layer: 'infra', type: 'data', radius: 7, phi: Math.PI, theta: 7*Math.PI/4, vulns: ['Amplification DDoS', 'No Auth'], nextSteps: ['Memcrashed', 'Key Brute'], difficulty: 1 },
            
            // Core Layer (inner, radius 4)
            { name: 'Primary DB (PostgreSQL)', layer: 'core', type: 'data', radius: 4, phi: Math.PI/6, theta: Math.PI/2, vulns: ['SQLi Time-Based', 'Privilege Escalation'], nextSteps: ['SQLMap', 'pg_dump Abuse'], difficulty: 4 },
            { name: 'Secrets Manager (Vault)', layer: 'core', type: 'secrets', radius: 4, phi: Math.PI/3, theta: Math.PI, vulns: ['Policy Misconfig', 'Seal Bypass'], nextSteps: ['Vault CLI Pivot', 'Token Replay'], difficulty: 6 },
            { name: 'Auth Server (LDAP)', layer: 'core', type: 'auth', radius: 4, phi: Math.PI/2, theta: 3*Math.PI/2, vulns: ['Pass-the-Ticket', 'Kerberoasting'], nextSteps: ['Mimikatz', 'BloodHound'], difficulty: 5 },
            { name: 'File Store (S3)', layer: 'core', type: 'data', radius: 4, phi: 2*Math.PI/3, theta: 0, vulns: ['Bucket Perms', 'Shadow Copies'], nextSteps: ['AWS CLI Enum', 'Pacu Framework'], difficulty: 3 },
            { name: 'Monitoring (ELK)', layer: 'core', type: 'log', radius: 4, phi: 5*Math.PI/6, theta: Math.PI/2, vulns: ['Log Injection', 'Kibana RCE'], nextSteps: ['ElastAlert Abuse', 'KQL Injection'], difficulty: 4 }
        ];

        // Expanded Connections with difficulties
        const connectionData = [
            [0, 4], [1, 5], [2, 4], [3, 5], // Perimeter to Infra
            [4, 6], [5, 6], [4, 7], [6, 8], [7, 9], // Infra internals
            [6, 10], [8, 11], [9, 12], [10, 13], [11, 14] // Core pivots
        ];

        function init() {
            try {
                console.log('Starting Stark Globe init...');
                console.log('Three.js loaded:', THREE.REVISION);

                // Scene setup - Darker, more atmospheric
                window.scene = new THREE.Scene();
                window.scene.fog = new THREE.Fog(0x0a0a0a, 5, 60);
                console.log('Scene created');

                window.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                window.camera.position.set(0, 0, 25);
                console.log('Camera created');

                window.renderer = new THREE.WebGLRenderer({ antialias: true });
                window.renderer.setSize(window.innerWidth, window.innerHeight);
                window.renderer.setClearColor(0x0a0a0a);
                window.renderer.shadowMap.enabled = true;
                window.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                window.renderer.toneMapping = THREE.ReinhardToneMapping;
                window.renderer.toneMappingExposure = 1.2;
                document.body.appendChild(window.renderer.domElement);
                console.log('Renderer created');

                // Post-processing for ultimate glow
                window.composer = new EffectComposer(window.renderer);
                const renderPass = new RenderPass(window.scene, window.camera);
                window.composer.addPass(renderPass);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.0, 0.5, 0.1);
                window.composer.addPass(bloomPass);
                console.log('Composer and Bloom setup');

                // Controls with limits
                window.controls = new OrbitControls(window.camera, window.renderer.domElement);
                window.controls.enableDamping = true;
                window.controls.dampingFactor = 0.05;
                window.controls.minDistance = 5;
                window.controls.maxDistance = 50;
                console.log('Controls created');

                // Raycaster
                window.raycaster = new THREE.Raycaster();
                window.mouse = new THREE.Vector2();
                console.log('Raycaster created');

                // Enhanced Lighting for ultimate visuals
                const ambientLight = new THREE.AmbientLight(0x002200, 0.6);
                window.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0x00aa00, 1.0);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                window.scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0x004400, 1.0, 100);
                pointLight.position.set(0, 0, 0);
                window.scene.add(pointLight);
                console.log('Lighting added');

                // Create everything
                createLayers();
                createNodes();
                createConnections();
                createAdvancedParticles();
                createHolographicEffects();
                console.log('All objects created');

                // Events
                window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('click', onMouseClick, false);
                window.renderer.domElement.addEventListener('mousemove', onMouseMove, false);

                document.getElementById('loading').style.display = 'none';
                animate();
                updateVulnCount();
                console.log('Stark Globe initialized successfully. Ready for orbital insertion.');
            } catch (error) {
                console.error('Init error details:', error);
                document.getElementById('loading').innerHTML += '<br><span style="color:#ff4444;">Init failed—check console for details.</span>';
            }
        }

        function createLayers() {
            const layerRadii = { perimeter: 12, infra: 7, core: 4 };
            const layerColors = { perimeter: 0x440000, infra: 0x444400, core: 0x004400 };

            Object.keys(layerRadii).forEach(layer => {
                const geometry = new THREE.SphereGeometry(layerRadii[layer], 128, 64); // Ultra smooth
                const material = new THREE.MeshBasicMaterial({ 
                    color: layerColors[layer], 
                    wireframe: true, 
                    transparent: true, 
                    opacity: 0.1,
                    linewidth: 0.3
                });
                window.layers[layer] = new THREE.Group();
                const sphere = new THREE.Mesh(geometry, material);
                window.layers[layer].add(sphere);
                window.scene.add(window.layers[layer]);
            });
        }

        function createNodes() {
            nodeData.forEach((data, index) => {
                const x = data.radius * Math.sin(data.phi) * Math.cos(data.theta);
                const y = data.radius * Math.sin(data.phi) * Math.sin(data.theta);
                const z = data.radius * Math.cos(data.phi);

                // Ultimate node: Icosahedron with high emissive for bloom
                const geometry = new THREE.IcosahedronGeometry(0.25, 2); // Higher detail
                const material = new THREE.MeshStandardMaterial({ 
                    color: getLayerColor(data.layer),
                    emissive: new THREE.Color(getLayerColor(data.layer)).multiplyScalar(0.5), // High emissive for bloom
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 0.95
                });
                const node = new THREE.Mesh(geometry, material);
                node.position.set(x, y, z);
                node.userData = { ...data, index, originalPos: new THREE.Vector3(x, y, z) };
                node.castShadow = true;
                node.receiveShadow = true;
                window.layers[data.layer].add(node);
                window.nodes.push(node);

                // Enhanced label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'rgba(10,10,10,0.8)';
                context.fillRect(0, 0, 256, 64);
                context.strokeStyle = '#00aa00';
                context.lineWidth = 2;
                context.strokeRect(0, 0, 256, 64);
                context.fillStyle = '#00aa00';
                context.font = 'bold 16px Courier New';
                context.fillText(data.name, 10, 40);
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(node.position);
                sprite.position.y += 0.6;
                sprite.scale.set(2.5, 0.6, 1);
                window.layers[data.layer].add(sprite);
                node.userData.label = sprite;

                // Node-specific point light for enhanced glow
                const nodeLight = new THREE.PointLight(getLayerColor(data.layer), 0.5, 2);
                nodeLight.position.copy(node.position);
                window.scene.add(nodeLight);
            });
        }

        function createConnections() {
            connectionData.forEach(([i1, i2]) => {
                const node1 = window.nodes[i1];
                const node2 = window.nodes[i2];
                const points = [];
                points.push(node1.position.clone());
                points.push(node2.position.clone());
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x003366, 
                    transparent: true, 
                    opacity: 0.6,
                    linewidth: 2
                });
                const line = new THREE.Line(geometry, material);
                window.scene.add(line);
                line.userData = { nodes: [node1, node2], difficulty: Math.max(nodeData[i1].difficulty, nodeData[i2].difficulty) };
                window.connections.push(line);
            });
        }

        function createAdvancedParticles() {
            // Enhanced multi-layer particles with more count
            for (let i = 0; i < 5; i++) { // More layers
                const particlesGeometry = new THREE.BufferGeometry();
                const particlesCnt = 3000; // Increased
                const posArray = new Float32Array(particlesCnt * 3);
                const velArray = new Float32Array(particlesCnt * 3);
                for (let j = 0; j < particlesCnt * 3; j += 3) {
                    const radius = 3 + i * 8;
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI * 2;
                    posArray[j] = radius * Math.sin(phi) * Math.cos(theta);
                    posArray[j+1] = radius * Math.sin(phi) * Math.sin(theta);
                    posArray[j+2] = radius * Math.cos(phi);
                    velArray[j] = (Math.random() - 0.5) * 0.02;
                    velArray[j+1] = (Math.random() - 0.5) * 0.02;
                    velArray[j+2] = (Math.random() - 0.5) * 0.02;
                }
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                particlesGeometry.setAttribute('velocity', new THREE.BufferAttribute(velArray, 3));
                const particlesMaterial = new THREE.PointsMaterial({
                    size: 0.03,
                    color: 0x002200,
                    transparent: true,
                    opacity: 0.4
                });
                const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
                particlesMesh.userData = { type: 'particles', positions: posArray, velocities: velArray };
                window.scene.add(particlesMesh);
            }
        }

        function createHolographicEffects() {
            // Enhanced central holographic core with rotation and bloom trigger
            const coreGeometry = new THREE.TorusKnotGeometry(1, 0.3, 100, 16);
            const coreMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x004400, 
                emissive: 0x004400,
                emissiveIntensity: 0.8, // High for bloom
                transparent: true, 
                opacity: 0.7,
                metalness: 1,
                roughness: 0,
                side: THREE.DoubleSide
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            window.scene.add(core);
        }

        function getLayerColor(layer) {
            const colors = { perimeter: 0xcc0000, infra: 0xccaa00, core: 0x00aa00 };
            return colors[layer] || 0x666666;
        }

        function getRGBFromColor(colorHex) {
            return {
                r: (colorHex >> 16) / 255,
                g: ((colorHex >> 8) & 0xff) / 255,
                b: (colorHex & 0xff) / 255
            };
        }

        function onWindowResize() {
            window.camera.aspect = window.innerWidth / window.innerHeight;
            window.camera.updateProjectionMatrix();
            window.renderer.setSize(window.innerWidth, window.innerHeight);
            window.composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            window.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            window.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            window.raycaster.setFromCamera(window.mouse, window.camera);
            const intersects = window.raycaster.intersectObjects(window.nodes);
            if (intersects.length > 0) {
                const node = intersects[0].object;
                showNodeInfo(node);
                highlightNode(node);
                if (window.showPaths) animatePathFrom(node.userData.index);
            }
        }

        function onMouseMove(event) {
            window.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            window.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            window.raycaster.setFromCamera(window.mouse, window.camera);
            const intersects = window.raycaster.intersectObjects(window.nodes);
            window.nodes.forEach(n => n.material.emissiveIntensity = 0.5);
            if (intersects.length > 0) {
                intersects[0].object.material.emissiveIntensity = 1.5; // High for bloom
            }
        }

        function showNodeInfo(node) {
            const data = node.userData;
            document.getElementById('node-title').textContent = data.name + ' [' + data.layer.toUpperCase() + ']';
            const details = document.getElementById('node-details');
            details.innerHTML = `
                <li><strong>Type:</strong> ${data.type.toUpperCase()}</li>
                <li><strong>Key Vulns:</strong> ${data.vulns.join(' | ')}</li>
                <li><strong>Next Vectors:</strong> ${data.nextSteps.join(' | ')}</li>
                <li><strong>Difficulty:</strong> ${data.difficulty}/10</li>
                <li><strong>Guidance:</strong> Focus on ${data.layer} layer; ignore peripheral noise like unrelated APIs.</li>
            `;
            const loopholes = document.getElementById('layer-loopholes');
            loopholes.innerHTML = layerLoopholes[data.layer].map(v => `<li>${v}</li>`).join('');
            document.getElementById('info-panel').style.display = 'block';
        }

        function highlightNode(node) {
            gsap.to(node.material, { duration: 0.8, emissiveIntensity: 2.0, yoyo: true, repeat: 1 });
            gsap.to(node.scale, { duration: 0.8, x: 1.5, y: 1.5, z: 1.5, yoyo: true, repeat: 1 });
            if (node.userData.label) {
                gsap.to(node.userData.label.scale, { duration: 0.8, x: 3.5, y: 0.9, yoyo: true, repeat: 1 });
            }
        }

        function animatePathFrom(startIndex) {
            window.connections.forEach((conn, i) => {
                const [i1, i2] = connectionData[i];
                if (i1 === startIndex || i2 === startIndex) {
                    gsap.to(conn.material, { duration: 1.5, opacity: 1.0 });
                    gsap.to(conn.scale, { duration: 1.5, z: 1.8, yoyo: true, repeat: 2 });
                    const color = conn.userData.difficulty > 4 ? 0xff4444 : 0x00aa00;
                    const rgb = getRGBFromColor(color);
                    gsap.to(conn.material.color, { duration: 0.5, ...rgb, yoyo: true, repeat: 1 });
                }
            });
        }

        function resetView() {
            window.controls.reset();
            document.getElementById('info-panel').style.display = 'none';
            window.nodes.forEach(n => {
                n.material.emissiveIntensity = 0.5;
                n.scale.set(1,1,1);
            });
            if (window.exploded) explodeView();
        }

        function togglePaths() {
            window.showPaths = !window.showPaths;
            window.connections.forEach(conn => conn.visible = window.showPaths);
        }

        function explodeView() {
            window.exploded = !window.exploded;
            const offset = window.exploded ? 6 : 0;
            Object.keys(window.layers).forEach(layer => {
                gsap.to(window.layers[layer].position, {
                    duration: 1.5,
                    x: layer === 'perimeter' ? offset : 0,
                    y: layer === 'infra' ? offset : 0,
                    z: layer === 'core' ? -offset : 0,
                    ease: "power2.inOut"
                });
            });
            window.nodes.forEach(node => {
                gsap.to(node.position, {
                    duration: 1.5,
                    x: node.position.x * (1 + offset / node.userData.radius),
                    y: node.position.y * (1 + offset / node.userData.radius),
                    z: node.position.z * (1 + offset / node.userData.radius),
                    ease: "power2.inOut"
                });
            });
        }

        function simulateAttack() {
            const breachPath = [0, 4, 6, 10];
            breachPath.forEach((idx, step) => {
                setTimeout(() => {
                    const node = window.nodes[idx];
                    gsap.to(node.material, { duration: 1, emissiveIntensity: 3.0 });
                    const vulnRGB = getRGBFromColor(0xff4444);
                    gsap.to(node.material.color, { duration: 1, ...vulnRGB });
                    gsap.to(node.scale, { duration: 1, x: 2.5, y: 2.5, z: 2.5, yoyo: true, repeat: 1 });
                }, step * 800);
            });
            if (typeof AudioContext !== 'undefined') {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                oscillator.connect(audioCtx.destination);
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.start();
                setTimeout(() => oscillator.stop(), 3000);
            }
        }

        function searchNodes(event) {
            const query = event.target.value.toLowerCase();
            window.nodes.forEach(node => {
                const visible = node.userData.name.toLowerCase().includes(query) || query === '';
                node.visible = visible;
                node.userData.label.visible = visible;
                window.connections.forEach(conn => {
                    const [n1, n2] = conn.userData.nodes;
                    conn.visible = window.showPaths && n1.visible && n2.visible;
                });
            });
        }

        function scanForVulns() {
            if (window.scanning) return;
            window.scanning = true;
            window.vulnCount = 0;
            const results = [];
            window.nodes.forEach((node, i) => {
                const hasVuln = Math.random() > 0.3;
                if (hasVuln) {
                    window.vulnCount++;
                    const vulnRGB = getRGBFromColor(0xff4444);
                    gsap.to(node.material, {
                        duration: 0.5,
                        emissiveIntensity: 2.5,
                        delay: i * 0.05
                    });
                    gsap.to(node.material.color, {
                        duration: 0.5,
                        ...vulnRGB,
                        delay: i * 0.05
                    });
                    results.push(`${node.userData.name}: ${node.userData.vulns[0]} detected`);
                    setTimeout(() => {
                        const originalRGB = getRGBFromColor(getLayerColor(node.userData.layer));
                        gsap.to(node.material, { duration: 1, emissiveIntensity: 0.5 });
                        gsap.to(node.material.color, { duration: 1, ...originalRGB });
                    }, 500 + i * 50);
                }
            });
            updateVulnCount();
            document.getElementById('results-list').innerHTML = results.slice(0, 5).join('<br>') + (results.length > 5 ? '<br>... and more' : '');
            document.getElementById('scan-results').style.display = 'block';
            setTimeout(() => { document.getElementById('scan-results').style.display = 'none'; window.scanning = false; }, 5000);
        }

        function closeScan() {
            document.getElementById('scan-results').style.display = 'none';
        }

        function updateVulnCount() {
            document.getElementById('vuln-count').textContent = window.vulnCount;
        }

        function animate() {
            requestAnimationFrame(animate);
            window.controls.update();

            // Enhanced animations
            Object.values(window.layers).forEach(layer => layer.rotation.y += 0.003);
            window.scene.fog.density = 0.05 + Math.sin(Date.now() * 0.0003) * 0.02; // Dynamic fog

            // Particle movement
            if (Date.now() % 1 === 0) {
                window.scene.traverse(obj => {
                    if (obj.userData && obj.userData.type === 'particles') {
                        const positions = obj.geometry.attributes.position.array;
                        const velocities = obj.geometry.attributes.velocity.array;
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] += velocities[i];
                            positions[i+1] += velocities[i+1];
                            positions[i+2] += velocities[i+2];
                            if (Math.abs(positions[i]) > 40) velocities[i] *= -1;
                            if (Math.abs(positions[i+1]) > 40) velocities[i+1] *= -1;
                            if (Math.abs(positions[i+2]) > 40) velocities[i+2] *= -1;
                        }
                        obj.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }

            // Holographic core enhanced pulse
            const core = window.scene.children.find(c => c.geometry && c.geometry.type === 'TorusKnotGeometry');
            if (core) {
                core.rotation.x += 0.015;
                core.rotation.y += 0.008;
                core.material.emissiveIntensity = 0.8 + Math.sin(Date.now() * 0.0015) * 0.4;
                core.material.opacity = 0.5 + Math.sin(Date.now() * 0.002) * 0.3;
            }

            // Central light pulse
            const pointLight = window.scene.children.find(c => c.type === 'PointLight' && c.position.length() === 0);
            if (pointLight) pointLight.intensity = 1.0 + Math.sin(Date.now() * 0.0008) * 0.5;

            window.composer.render();
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
